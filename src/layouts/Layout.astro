---
export interface Props {
	title: string;
	description?: string;
}

const { title, description = "Legalizamos tu instalación eléctrica de forma rápida y sin complicaciones. Boletines eléctricos CIE, tramitación ante Industria y distribuidoras. ¡Presupuesto en 2 horas!" } = Astro.props;
---

<!DOCTYPE html>
<html lang="es-ES">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{title}</title>
	<meta name="description" content={description}>
	<link rel="icon" type="image/svg+xml" href={import.meta.env.BASE_URL + "favicon.svg"} />
	<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>

<body>
	<slot/>

	<script is:inline>
		// Intersection Observer para animaciones de scroll
		const observerOptions = {
			root: null,
			rootMargin: '0px',
			threshold: 0.3
		};

		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					entry.target.classList.add('in-view');
				}
			});
		}, observerOptions);

		// Observar elementos intro-content
		const introContent = document.querySelector('.intro-content');
		const introSection = document.querySelector('.intro-section');
		
		if (introContent && introSection) {
			// Crear observer con callback específico para intro
			const introObserver = new IntersectionObserver((entries) => {
				entries.forEach(entry => {
					if (entry.isIntersecting) {
						// Añadir clase in-view al contenido
						entry.target.classList.add('in-view');
					}
				});
			}, {
				root: null,
				rootMargin: '0px',
				threshold: 0.3
			});
			
			introObserver.observe(introContent);
			
			// Split texto en palabras para animación word-by-word
			const paragraph = introContent.querySelector('p');
			if (paragraph) {
				const text = paragraph.textContent;
				const words = text.split(' ');
				paragraph.innerHTML = words.map((word, index) => 
					`<span class="intro-text-word" style="transition-delay: ${0.05 + (index * 0.05)}s;">${word}</span>`
				).join(' ');
			}
		}

		// Responsive para animación del título hero
		function updateHeroTitleSize() {
			const heroTitle = document.querySelector('.hero-title');
			if (heroTitle) {
				if (window.innerWidth <= 921) {
					heroTitle.style.fontSize = '50px';
				} else if (window.innerWidth <= 544) {
					heroTitle.style.fontSize = '42px';
				} else {
					heroTitle.style.fontSize = '60px';
				}
			}
		}

		// Ejecutar al cargar la página y en resize
		updateHeroTitleSize();
		window.addEventListener('resize', updateHeroTitleSize);

		// Smooth scroll para enlaces de navegación
		document.querySelectorAll('a[href^="#"]').forEach(anchor => {
			anchor.addEventListener('click', function (e) {
				e.preventDefault();
				const target = document.querySelector(this.getAttribute('href'));
				if (target) {
					target.scrollIntoView({
						behavior: 'smooth',
						block: 'start'
					});
				}
			});
		});

		// Mejorar la experiencia del usuario con efectos hover en las cards
		document.querySelectorAll('.service-card, .benefit-card, .reason-item').forEach(card => {
			card.addEventListener('mouseenter', function() {
				this.style.transform = 'translateY(-5px) scale(1.02)';
			});
			
			card.addEventListener('mouseleave', function() {
				this.style.transform = 'translateY(0) scale(1)';
			});
		});

		// Animación de aparición progresiva para elementos
		const observeElements = () => {
			const elements = document.querySelectorAll('.benefit-card, .service-card, .reason-item, .proceso-feature');
			
			elements.forEach((element, index) => {
				element.style.opacity = '0';
				element.style.transform = 'translateY(30px)';
				element.style.transition = 'all 0.6s ease';
				element.style.transitionDelay = `${index * 0.1}s`;
			});

			const elementsObserver = new IntersectionObserver((entries) => {
				entries.forEach(entry => {
					if (entry.isIntersecting) {
						entry.target.style.opacity = '1';
						entry.target.style.transform = 'translateY(0)';
					}
				});
			}, { threshold: 0.2 });

			elements.forEach(element => {
				elementsObserver.observe(element);
			});
		};

		// Ejecutar animaciones cuando el DOM esté listo
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', observeElements);
		} else {
			observeElements();
		}
	</script>
</body>
</html>
